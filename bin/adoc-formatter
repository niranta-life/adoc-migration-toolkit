#!/bin/bash

# ADOC Export Import Formatter Script
# A tool for replacing substrings in JSON files and ZIP archives
#
# Usage: adoc-formatter [--input <input_dir>] --source-env-string <source> --target-env-string <target> [options]
# Example: adoc-formatter --source-env-string "PROD_DB" --target-env-string "DEV_DB" --verbose
#
# Author: ADOC Export Import Team
# Version: 1.0.0

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Script configuration
SCRIPT_NAME="adoc-formatter"
SCRIPT_VERSION="1.0.0"
DEFAULT_PYTHON="python3"

# Initialize PYTHONPATH if not set
PYTHONPATH="${PYTHONPATH:-}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Log level configuration
LOG_LEVEL="ERROR"
LOG_LEVELS=("ERROR" "WARNING" "INFO" "SUCCESS")

# Function to get log level index
get_log_level_index() {
    local level="$1"
    for i in "${!LOG_LEVELS[@]}"; do
        if [[ "${LOG_LEVELS[$i]}" == "$level" ]]; then
            echo "$i"
            return
        fi
    done
    echo "0" # Default to ERROR if not found
}

# Logging functions (respect log level)
log_info() {
    local msg_level="INFO"
    if (( $(get_log_level_index "$LOG_LEVEL") >= $(get_log_level_index "$msg_level") )); then
        echo -e "${BLUE}[INFO]${NC} $1"
    fi
}

log_success() {
    local msg_level="SUCCESS"
    if (( $(get_log_level_index "$LOG_LEVEL") >= $(get_log_level_index "$msg_level") )); then
        echo -e "${GREEN}[SUCCESS]${NC} $1"
    fi
}

log_warning() {
    local msg_level="WARNING"
    if (( $(get_log_level_index "$LOG_LEVEL") >= $(get_log_level_index "$msg_level") )); then
        echo -e "${YELLOW}[WARNING]${NC} $1"
    fi
}

log_error() {
    local msg_level="ERROR"
    if (( $(get_log_level_index "$LOG_LEVEL") >= $(get_log_level_index "$msg_level") )); then
        echo -e "${RED}[ERROR]${NC} $1"
    fi
}

# Print usage information
print_usage() {
    cat << EOF
${SCRIPT_NAME} v${SCRIPT_VERSION} - Professional JSON String Replacer

DESCRIPTION:
    Replace substrings in JSON files and ZIP archives with comprehensive error handling.
    Processes entire directories efficiently with professional output formatting.
    Auto-detects input directory from policy-export subdirectory if not specified.

USAGE:
    ${SCRIPT_NAME} [--input <input_dir>] --source-env-string <source> --target-env-string <target> [options]

ARGUMENTS:
    --source-env-string <string>  Substring to search for (source environment) [REQUIRED]
    --target-env-string <string>  Substring to replace with (target environment) [REQUIRED]

OPTIONS:
    --input <dir>                 Input directory (auto-detected from policy-export if not specified)
    --output-dir <dir>            Output directory (defaults to organized subdirectories)
    --log-level|-l               Set log level (ERROR, WARNING, INFO, DEBUG)
    --verbose, -v                 Enable verbose logging
    --help, -h                    Show this help message
    --version                     Show version information

EXAMPLES:
    ${SCRIPT_NAME} --source-env-string "PROD_DB" --target-env-string "DEV_DB"
    ${SCRIPT_NAME} --input data/samples --source-env-string "old" --target-env-string "new" --output-dir data/output
    ${SCRIPT_NAME} --source-env-string "COMM_APAC_ETL_PROD_DB" --target-env-string "NEW_DB_NAME" --verbose

FEATURES:
    - Processes JSON files and ZIP archives
    - Maintains file structure and count
    - Comprehensive error handling and logging
    - Professional output formatting
    - Extracts data quality policy assets to CSV
    - Auto-detects input directory from policy-export subdirectory
    - Organized output directory structure

EXIT CODES:
    0 - Success
    1 - Error occurred
    2 - Invalid arguments

EOF
}

# Print version information
print_version() {
    echo "${SCRIPT_NAME} v${SCRIPT_VERSION}"
    echo "Professional JSON String Replacer for ADOC Export Import"
}

# Validate arguments
validate_arguments() {
    local source_string="$1"
    local target_string="$2"

    # Validate source string
    if [[ -z "$source_string" ]]; then
        log_error "Source environment string cannot be empty"
        return 1
    fi

    # Validate target string
    if [[ -z "$target_string" ]]; then
        log_error "Target environment string cannot be empty"
        return 1
    fi

    return 0
}

# Find the adoc_export_import module
find_adoc_module() {
    # Try to find the module in common locations
    local possible_paths=(
        "$(dirname "$0")/src"
        "$(pwd)/src"
        "$(dirname "$0")/../src"
        "$(pwd)/../src"
        "$HOME/.local/lib/python*/site-packages"
        "/usr/local/lib/python*/site-packages"
        "/usr/lib/python*/site-packages"
    )

    for path in "${possible_paths[@]}"; do
        if [[ -d "$path" ]] && [[ -f "$path/adoc_export_import/__init__.py" ]]; then
            echo "$path"
            return 0
        fi
    done

    # Check if it's installed via pip
    if python3 -c "import adoc_export_import" 2>/dev/null; then
        echo "installed"
        return 0
    fi

    return 1
}

# Main function
main() {
    local input_dir=""
    local source_string=""
    local target_string=""
    local output_dir=""
    local verbose_flag=""
    local additional_args=()

    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                print_usage
                exit 0
                ;;
            --version)
                print_version
                exit 0
                ;;
            --input)
                if [[ -z "$2" ]]; then
                    log_error "--input requires a directory path"
                    exit 2
                fi
                input_dir="--input $2"
                shift 2
                ;;
            --output-dir)
                if [[ -z "$2" ]]; then
                    log_error "--output-dir requires a directory path"
                    exit 2
                fi
                output_dir="--output-dir $2"
                shift 2
                ;;
            --source-env-string)
                if [[ -z "$2" ]]; then
                    log_error "--source-env-string requires a string value"
                    exit 2
                fi
                source_string="$2"
                shift 2
                ;;
            --target-env-string)
                if [[ -z "$2" ]]; then
                    log_error "--target-env-string requires a string value"
                    exit 2
                fi
                target_string="$2"
                shift 2
                ;;
            --log-level|-l)
                if [[ -z "$2" ]]; then
                    log_error "--log-level requires a level (ERROR, WARNING, INFO, DEBUG)"
                    exit 2
                fi
                LOG_LEVEL="$2"
                LOG_LEVEL=$(echo "$LOG_LEVEL" | tr '[:lower:]' '[:upper:]')
                shift 2
                ;;
            --log-level=*)
                LOG_LEVEL="${1#*=}"
                LOG_LEVEL=$(echo "$LOG_LEVEL" | tr '[:lower:]' '[:upper:]')
                shift
                ;;
            --verbose|-v)
                verbose_flag="--verbose"
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                print_usage
                exit 2
                ;;
            *)
                additional_args+=("$1")
                shift
                ;;
        esac
    done

    # Check if required arguments are provided
    if [[ -z "$source_string" ]] || [[ -z "$target_string" ]]; then
        log_error "Missing required arguments: --source-env-string and --target-env-string"
        print_usage
        exit 2
    fi

    # Validate arguments
    if ! validate_arguments "$source_string" "$target_string"; then
        exit 1
    fi

    # Find the adoc_export_import module
    log_info "Locating adoc_export_import module..."
    local module_path
    if ! module_path=$(find_adoc_module); then
        log_error "Could not find adoc_export_import module"
        log_error "Please ensure the module is installed or the src directory is accessible"
        exit 1
    fi

    # Build the command
    local cmd=""
    if [[ "$module_path" == "installed" ]]; then
        cmd="$DEFAULT_PYTHON -m adoc_export_import formatter"
    else
        cmd="$DEFAULT_PYTHON -m adoc_export_import formatter"
        # Add the module path to PYTHONPATH
        if [[ -n "${PYTHONPATH:-}" ]]; then
            export PYTHONPATH="$module_path:${PYTHONPATH:-}"
        else
            export PYTHONPATH="$module_path"
        fi
    fi

    # Add required arguments
    cmd="$cmd --source-env-string=\"$source_string\" --target-env-string=\"$target_string\""

    # Add optional arguments
    if [[ -n "$input_dir" ]]; then
        cmd="$cmd $input_dir"
    fi

    if [[ -n "$output_dir" ]]; then
        cmd="$cmd $output_dir"
    fi

    # Add log level argument
    cmd="$cmd --log-level=\"$LOG_LEVEL\""

    if [[ -n "$verbose_flag" ]]; then
        cmd="$cmd $verbose_flag"
    fi

    # Add any additional arguments
    if [[ ${#additional_args[@]} -gt 0 ]]; then
        cmd="$cmd ${additional_args[*]}"
    fi

    # Execute the command
    log_info "Executing: $cmd"
    if [[ -n "$input_dir" ]]; then
        log_info "Input directory: $input_dir"
    else
        log_info "Input directory: auto-detected from policy-export subdirectory"
    fi
    log_info "Replacing: '$source_string' -> '$target_string'"

    if eval "$cmd"; then
        log_success "Formatter completed successfully"
        exit 0
    else
        log_error "Formatter failed with exit code $?"
        exit 1
    fi
}

# Handle script interruption
trap 'log_error "Script interrupted by user"; exit 1' INT TERM

# Run main function with all arguments
main "$@" 