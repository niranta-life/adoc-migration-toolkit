#!/bin/bash

# ADOC Export Import Formatter Script
# A tool for replacing substrings in JSON files and ZIP archives
#
# Usage: adoc-formatter <input_dir> <source_string> <target_string> [options]
# Example: adoc-formatter data/samples "PROD_DB" "DEV_DB" --verbose
#
# Author: ADOC Export Import Team
# Version: 1.0.0

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Script configuration
SCRIPT_NAME="adoc-formatter"
SCRIPT_VERSION="1.0.0"
DEFAULT_PYTHON="python3"

# Initialize PYTHONPATH if not set
PYTHONPATH="${PYTHONPATH:-}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Log level configuration
LOG_LEVEL="ERROR"
LOG_LEVELS=("ERROR" "WARNING" "INFO" "SUCCESS")

# Function to get log level index
get_log_level_index() {
    local level="$1"
    for i in "${!LOG_LEVELS[@]}"; do
        if [[ "${LOG_LEVELS[$i]}" == "$level" ]]; then
            echo "$i"
            return
        fi
    done
    echo "0" # Default to ERROR if not found
}

# Logging functions (respect log level)
log_info() {
    local msg_level="INFO"
    if (( $(get_log_level_index "$LOG_LEVEL") >= $(get_log_level_index "$msg_level") )); then
        echo -e "${BLUE}[INFO]${NC} $1"
    fi
}

log_success() {
    local msg_level="SUCCESS"
    if (( $(get_log_level_index "$LOG_LEVEL") >= $(get_log_level_index "$msg_level") )); then
        echo -e "${GREEN}[SUCCESS]${NC} $1"
    fi
}

log_warning() {
    local msg_level="WARNING"
    if (( $(get_log_level_index "$LOG_LEVEL") >= $(get_log_level_index "$msg_level") )); then
        echo -e "${YELLOW}[WARNING]${NC} $1"
    fi
}

log_error() {
    local msg_level="ERROR"
    if (( $(get_log_level_index "$LOG_LEVEL") >= $(get_log_level_index "$msg_level") )); then
        echo -e "${RED}[ERROR]${NC} $1"
    fi
}

# Print usage information
print_usage() {
    cat << EOF
${SCRIPT_NAME} v${SCRIPT_VERSION} - Professional JSON String Replacer

DESCRIPTION:
    Replace substrings in JSON files and ZIP archives with comprehensive error handling.
    Processes entire directories efficiently with professional output formatting.

USAGE:
    ${SCRIPT_NAME} <input_dir> <source_string> <target_string> [options]

ARGUMENTS:
    input_dir       Directory containing JSON files and ZIP files to process
    source_string   Substring to search for (source environment)
    target_string   Substring to replace with (target environment)

OPTIONS:
    --output-dir <dir>  Output directory (defaults to input_dir with '_import_ready' suffix)
    --log-level|-l     Set log level (ERROR, WARNING, INFO, SUCCESS)
    --verbose, -v       Enable verbose logging
    --help, -h          Show this help message
    --version           Show version information

EXAMPLES:
    ${SCRIPT_NAME} data/samples "PROD_DB" "DEV_DB"
    ${SCRIPT_NAME} data/samples "old" "new" --output-dir data/output
    ${SCRIPT_NAME} data/samples "COMM_APAC_ETL_PROD_DB" "NEW_DB_NAME" --verbose

FEATURES:
    - Processes JSON files and ZIP archives
    - Maintains file structure and count
    - Comprehensive error handling and logging
    - Professional output formatting
    - Extracts data quality policy assets to CSV

EXIT CODES:
    0 - Success
    1 - Error occurred
    2 - Invalid arguments

EOF
}

# Print version information
print_version() {
    echo "${SCRIPT_NAME} v${SCRIPT_VERSION}"
    echo "Professional JSON String Replacer for ADOC Export Import"
}

# Validate arguments
validate_arguments() {
    local input_dir="$1"
    local source_string="$2"
    local target_string="$3"

    # Check if input directory exists
    if [[ ! -d "$input_dir" ]]; then
        log_error "Input directory does not exist: $input_dir"
        return 1
    fi

    # Check if input directory is readable
    if [[ ! -r "$input_dir" ]]; then
        log_error "Input directory is not readable: $input_dir"
        return 1
    fi

    # Validate source string
    if [[ -z "$source_string" ]]; then
        log_error "Source string cannot be empty"
        return 1
    fi

    # Validate target string
    if [[ -z "$target_string" ]]; then
        log_error "Target string cannot be empty"
        return 1
    fi

    return 0
}

# Find the adoc_export_import module
find_adoc_module() {
    # Try to find the module in common locations
    local possible_paths=(
        "$(dirname "$0")/src"
        "$(pwd)/src"
        "$(dirname "$0")/../src"
        "$(pwd)/../src"
        "$HOME/.local/lib/python*/site-packages"
        "/usr/local/lib/python*/site-packages"
        "/usr/lib/python*/site-packages"
    )

    for path in "${possible_paths[@]}"; do
        if [[ -d "$path" ]] && [[ -f "$path/adoc_export_import/__init__.py" ]]; then
            echo "$path"
            return 0
        fi
    done

    # Check if it's installed via pip
    if python3 -c "import adoc_export_import" 2>/dev/null; then
        echo "installed"
        return 0
    fi

    return 1
}

# Main function
main() {
    local input_dir=""
    local source_string=""
    local target_string=""
    local output_dir=""
    local verbose_flag=""
    local additional_args=()

    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                print_usage
                exit 0
                ;;
            --version)
                print_version
                exit 0
                ;;
            --output-dir)
                if [[ -z "$2" ]]; then
                    log_error "--output-dir requires a directory path"
                    exit 2
                fi
                output_dir="--output-dir $2"
                shift 2
                ;;
            --log-level|-l)
                if [[ -z "$2" ]]; then
                    log_error "--log-level requires a level (ERROR, WARNING, INFO, SUCCESS)"
                    exit 2
                fi
                LOG_LEVEL="$2"
                LOG_LEVEL=$(echo "$LOG_LEVEL" | tr '[:lower:]' '[:upper:]')
                shift 2
                ;;
            --log-level=*)
                LOG_LEVEL="${1#*=}"
                LOG_LEVEL=$(echo "$LOG_LEVEL" | tr '[:lower:]' '[:upper:]')
                shift
                ;;
            --verbose|-v)
                verbose_flag="--verbose"
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                print_usage
                exit 2
                ;;
            *)
                if [[ -z "$input_dir" ]]; then
                    input_dir="$1"
                elif [[ -z "$source_string" ]]; then
                    source_string="$1"
                elif [[ -z "$target_string" ]]; then
                    target_string="$1"
                else
                    additional_args+=("$1")
                fi
                shift
                ;;
        esac
    done

    # Check if required arguments are provided
    if [[ -z "$input_dir" ]] || [[ -z "$source_string" ]] || [[ -z "$target_string" ]]; then
        log_error "Missing required arguments"
        print_usage
        exit 2
    fi

    # Validate arguments
    if ! validate_arguments "$input_dir" "$source_string" "$target_string"; then
        exit 1
    fi

    # Find the adoc_export_import module
    log_info "Locating adoc_export_import module..."
    local module_path
    if ! module_path=$(find_adoc_module); then
        log_error "Could not find adoc_export_import module"
        log_error "Please ensure the module is installed or the src directory is accessible"
        exit 1
    fi

    # Build the command
    local cmd=""
    if [[ "$module_path" == "installed" ]]; then
        cmd="$DEFAULT_PYTHON -m adoc_export_import formatter"
    else
        cmd="$DEFAULT_PYTHON -m adoc_export_import formatter"
        # Add the module path to PYTHONPATH
        if [[ -n "${PYTHONPATH:-}" ]]; then
            export PYTHONPATH="$module_path:${PYTHONPATH:-}"
        else
            export PYTHONPATH="$module_path"
        fi
    fi

    # Add arguments
    cmd="$cmd --input=\"$input_dir\" --source-env-string=\"$source_string\" --target-env-string=\"$target_string\""

    # Add optional arguments
    if [[ -n "$output_dir" ]]; then
        cmd="$cmd $output_dir"
    fi

    # Add log level argument
    cmd="$cmd --log-level=\"$LOG_LEVEL\""

    if [[ -n "$verbose_flag" ]]; then
        cmd="$cmd $verbose_flag"
    fi

    # Add any additional arguments
    if [[ ${#additional_args[@]} -gt 0 ]]; then
        cmd="$cmd ${additional_args[*]}"
    fi

    # Execute the command
    log_info "Executing: $cmd"
    log_info "Processing directory: $input_dir"
    log_info "Replacing: '$source_string' -> '$target_string'"

    if eval "$cmd"; then
        log_success "Formatter completed successfully"
        exit 0
    else
        log_error "Formatter failed with exit code $?"
        exit 1
    fi
}

# Handle script interruption
trap 'log_error "Script interrupted by user"; exit 1' INT TERM

# Run main function with all arguments
main "$@" 